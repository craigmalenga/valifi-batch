<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Valifi Batch Runner (Mirror)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- SheetJS for Excel export -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f4f6fb;
            margin: 0;
            padding: 20px;
            color: #222;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.06);
            padding: 24px 28px 32px;
        }
        h1 { margin: 0 0 8px; font-size: 24px; }
        .subtitle { margin: 0 0 24px; color: #555; font-size: 13px; }
        .warning-box {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        .warning-box strong { color: #92400e; }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 24px;
            margin-bottom: 24px;
        }
        .card {
            border-radius: 12px;
            border: 1px solid #e3e6f0;
            padding: 16px 18px;
            background: #fafbff;
        }
        .card h2 { font-size: 16px; margin: 0 0 12px; }
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #444;
        }
        input[type="text"],
        input[type="password"],
        input[type="number"] {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #d0d4e0;
            font-size: 13px;
            outline: none;
        }
        input:focus {
            border-color: #4c6fff;
            box-shadow: 0 0 0 1px rgba(76,111,255,0.12);
        }
        .field { margin-bottom: 10px; }
        .field-inline { display: flex; gap: 8px; }
        .field-inline > div { flex: 1; }
        .file-label {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 14px;
            background: #4c6fff;
            color: #fff;
            border-radius: 999px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border: none;
            margin-bottom: 8px;
        }
        #csvFile { display: none; }
        .file-info { font-size: 11px; color: #555; margin-bottom: 10px; }
        button.action {
            padding: 8px 14px;
            border-radius: 999px;
            border: none;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        button.primary { background: #1ea672; color: #fff; }
        button.secondary { background: #e4e7f5; color: #222; }
        button.danger { background: #dc2626; color: #fff; }
        button.excel { background: #217346; color: #fff; }
        button.action:disabled { opacity: 0.4; cursor: default; }
        #log {
            background: #050816;
            color: #e5e7eb;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            font-family: Menlo, Monaco, Consolas, monospace;
            font-size: 12px;
            border-radius: 10px;
            margin-top: 6px;
            white-space: pre-wrap;
        }
        #previewTable, #resultsTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        #previewTable th, #previewTable td,
        #resultsTable th, #resultsTable td {
            border: 1px solid #e2e4f0;
            padding: 4px 6px;
            text-align: left;
        }
        #previewTable th, #resultsTable th {
            background: #f4f6ff;
            font-weight: 600;
        }
        .preview-container {
            max-height: 250px;
            overflow: auto;
        }
        .small { font-size: 11px; color: #666; }
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 11px;
            border: 1px solid;
            margin-right: 4px;
        }
        .badge-ok { border-color: #16a34a; color: #166534; background: #dcfce7; }
        .badge-error { border-color: #dc2626; color: #7f1d1d; background: #fee2e2; }
        .badge-skip { border-color: #ca8a04; color: #854d0e; background: #fef9c3; }
        code {
            background: #f1f5f9;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 11px;
        }
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e3e6f0;
            padding-bottom: 0;
        }
        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .tab-btn:hover {
            color: #4c6fff;
        }
        .tab-btn.active {
            color: #4c6fff;
            border-bottom-color: #4c6fff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Webhook Tab Styles */
        .webhook-input {
            width: 100%;
            height: 200px;
            font-family: Menlo, Monaco, Consolas, monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #d0d4e0;
            border-radius: 8px;
            resize: vertical;
        }
        .webhook-url-input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #d0d4e0;
            font-size: 12px;
            font-family: Menlo, Monaco, Consolas, monospace;
        }
        .lead-count {
            margin: 10px 0;
            padding: 8px 12px;
            background: #f0f4ff;
            border-radius: 6px;
            font-size: 13px;
        }
        .lead-count strong {
            color: #4c6fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Valifi Batch Runner (Mirror)</h1>
        <p class="subtitle">
            Private CSV ‚Üí <code>/query</code> ‚Üí <code>/upload_summary</code> tool for your mirror app.<br>
            Uses <code>skipFLG: true</code> to generate fake Lead IDs without hitting FLG API.
        </p>
        
        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-btn active" data-tab="batch">üìã Batch Processing</button>
            <button class="tab-btn" data-tab="webhook">üîó Send to Webhook</button>
        </div>
        
        <!-- Tab 1: Batch Processing -->
        <div id="tab-batch" class="tab-content active">
        
        <div class="warning-box">
            <strong>‚ö†Ô∏è Mirror Mode:</strong> This tool creates ClaimTracking records with fake Lead IDs. 
            No actual FLG API calls will be made. Data will be stored in your database for later processing.
        </div>

        <div class="grid">
            <!-- Left: Config + Upload -->
            <div class="card">
                <h2>1. Configuration</h2>
                <div class="field">
                    <label for="baseUrl">Backend Base URL (mirror app)</label>
                    <input id="baseUrl" type="text" value="https://valifi-batch.up.railway.app" placeholder="https://your-mirror-app.railway.app">
                </div>
                <div class="field-inline">
                    <div>
                        <label for="delayMs">Delay between records (ms)</label>
                        <input id="delayMs" type="number" value="1500" min="500">
                    </div>
                    <div>
                        <label for="maxRecords">Max records (0 = all)</label>
                        <input id="maxRecords" type="number" value="0" min="0">
                    </div>
                </div>
                
                <hr style="margin: 14px 0; border: none; border-top: 1px solid #e1e4f0;">
                
                <h2>2. CSV Upload</h2>
                <label class="file-label" for="csvFile">üìÑ Choose CSV File</label>
                <input id="csvFile" type="file" accept=".csv">
                <div class="file-info" id="fileInfo">No file chosen.</div>
                
                <button id="runBatchBtn" class="action primary" disabled>‚ñ∂ Run Batch</button>
                <button id="stopBtn" class="action danger" disabled>‚èπ Stop</button>
                <button id="exportBtn" class="action excel" disabled>üìä Export Excel</button>
                
                <p class="small" style="margin-top: 12px;">
                    <strong>Required CSV columns:</strong><br>
                    <code>first_name</code>, <code>last_name</code>, <code>email</code>, <code>mobile</code>,
                    <code>dob_day</code>, <code>dob_month</code>, <code>dob_year</code>,
                    <code>street</code>, <code>post_town</code>, <code>post_code</code><br><br>
                    <strong>Optional:</strong><br>
                    <code>title</code>, <code>middle_name</code>, <code>flat</code>, <code>building_name</code>, 
                    <code>building_number</code>, <code>district</code>, <code>county</code>,
                    <code>prev1_*</code>, <code>prev2_*</code> (previous addresses)
                </p>
            </div>

            <!-- Right: Preview -->
            <div class="card">
                <h2>3. CSV Preview</h2>
                <div id="previewContainer" class="preview-container small">No data loaded.</div>
            </div>
        </div>

        <div class="grid">
            <div class="card" style="grid-column: span 2;">
                <h2>4. Log</h2>
                <div id="log"></div>
            </div>
        </div>

        <div class="card" style="margin-top: 20px;">
            <h2>5. Results</h2>
            <div id="resultsContainer" class="small">No results yet.</div>
        </div>
        
        </div><!-- End Tab 1: Batch Processing -->
        
        <!-- Tab 2: Webhook -->
        <div id="tab-webhook" class="tab-content">
            <div class="card">
                <h2>Send Lead IDs to Webhook</h2>
                <p class="small" style="margin-bottom: 16px;">
                    Paste lead IDs from Excel (one per line or separated by tabs/commas). 
                    These will be sent to your WordPress webhook for processing.
                </p>
                
                <div class="field">
                    <label for="webhookUrl">Webhook URL</label>
                    <input id="webhookUrl" type="text" class="webhook-url-input" 
                           value="https://belmondclaims.com/wp-json/belmond-api/motor-finance-processing?secret=tYOCYpdskZBbxjSO87K" 
                           placeholder="https://your-site.com/webhook-endpoint">
                </div>
                
                <div class="field" style="margin-top: 12px;">
                    <label for="leadIdsInput">Lead IDs (paste from Excel)</label>
                    <textarea id="leadIdsInput" class="webhook-input" placeholder="Paste lead IDs here, one per line or separated by tabs/commas...

Example:
12345678
12345679
12345680

Or from Excel column:
12345678	12345679	12345680"></textarea>
                </div>
                
                <div class="lead-count" id="leadCountDisplay">
                    Lead IDs detected: <strong>0</strong>
                </div>
                
                <button id="parseLeadsBtn" class="action secondary">üîç Parse & Preview</button>
                <button id="sendWebhookBtn" class="action primary" disabled>üì§ Send to Webhook</button>
                <button id="clearLeadsBtn" class="action danger">üóëÔ∏è Clear</button>
                
                <div id="webhookLog" style="margin-top: 16px; display: none;">
                    <h3 style="font-size: 14px; margin-bottom: 8px;">Webhook Log</h3>
                    <div id="webhookLogContent" style="background: #050816; color: #e5e7eb; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
                </div>
                
                <div id="parsedLeadsPreview" style="margin-top: 16px; display: none;">
                    <h3 style="font-size: 14px; margin-bottom: 8px;">Parsed Lead IDs Preview</h3>
                    <div id="parsedLeadsList" style="background: #f8fafc; border: 1px solid #e2e4f0; border-radius: 8px; padding: 10px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 11px;"></div>
                </div>
            </div>
        </div><!-- End Tab 2: Webhook -->
        
    </div>

    <script>
    // ===== State =====
    let records = [];
    let stopRequested = false;
    let isRunning = false;
    
    // Data for Excel export - one row per Lead ID
    let exportData = [];

    // ===== Utilities =====
    function log(msg, level = "info") {
        const el = document.getElementById("log");
        const ts = new Date().toISOString().split("T")[1].slice(0, 8);
        const prefix = level === "error" ? "‚ùå" : level === "warn" ? "‚ö†Ô∏è" : level === "success" ? "‚úÖ" : "‚ÑπÔ∏è";
        el.textContent += `[${ts}] ${prefix} ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
        document.getElementById("log").textContent = "";
    }

    function formatDateYYYYMMDD(record) {
        const y = (record.dob_year || "").toString().trim();
        const m = (record.dob_month || "").toString().trim().padStart(2, "0");
        const d = (record.dob_day || "").toString().trim().padStart(2, "0");
        if (y && m && d && y.length === 4) {
            return `${y}-${m}-${d}`;
        }
        return "";
    }

    function buildPreviousAddress(record, prefix) {
        const postCode = (record[`${prefix}_post_code`] || "").trim();
        if (!postCode) return null;
        
        return {
            flat: (record[`${prefix}_flat`] || "").trim(),
            building_name: (record[`${prefix}_building_name`] || "").trim(),
            building_number: (record[`${prefix}_building_number`] || "").trim(),
            street: (record[`${prefix}_street`] || "").trim(),
            district: (record[`${prefix}_district`] || "").trim(),
            county: (record[`${prefix}_county`] || "").trim(),
            post_town: (record[`${prefix}_post_town`] || "").trim(),
            post_code: postCode
        };
    }

    function extractAccounts(valifiResponse) {
        // Try multiple paths where accounts might be
        if (valifiResponse?.data?.summaryReportV2?.accounts) {
            return valifiResponse.data.summaryReportV2.accounts;
        }
        if (valifiResponse?.data?.accounts) {
            return valifiResponse.data.accounts;
        }
        if (valifiResponse?.data?.summaryReport?.accounts) {
            return valifiResponse.data.summaryReport.accounts;
        }
        return [];
    }

    function extractPdfUrl(valifiResponse) {
        return valifiResponse?.data?.pdfUrl || "";
    }

    // Format any date to dd/mm/yyyy
    function formatDateDDMMYYYY(dateInput) {
        if (!dateInput) return "";
        
        let date;
        
        // Handle different input formats
        if (dateInput instanceof Date) {
            date = dateInput;
        } else if (typeof dateInput === "string") {
            // Try parsing ISO format (2024-12-11T12:22:13.000Z) or YYYY-MM-DD
            if (dateInput.includes("T")) {
                date = new Date(dateInput);
            } else if (dateInput.match(/^\d{4}-\d{2}-\d{2}$/)) {
                // YYYY-MM-DD format
                const parts = dateInput.split("-");
                return `${parts[2]}/${parts[1]}/${parts[0]}`;
            } else if (dateInput.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                // Already dd/mm/yyyy
                return dateInput;
            } else {
                // Try generic parse
                date = new Date(dateInput);
            }
        } else {
            return String(dateInput);
        }
        
        if (isNaN(date.getTime())) return String(dateInput);
        
        const day = String(date.getDate()).padStart(2, "0");
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const year = date.getFullYear();
        
        return `${day}/${month}/${year}`;
    }
    
    // Format datetime to dd/mm/yyyy hh:mm:ss
    function formatDateTimeDDMMYYYY(dateInput) {
        if (!dateInput) return "";
        
        const date = new Date(dateInput);
        if (isNaN(date.getTime())) return String(dateInput);
        
        const day = String(date.getDate()).padStart(2, "0");
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, "0");
        const mins = String(date.getMinutes()).padStart(2, "0");
        const secs = String(date.getSeconds()).padStart(2, "0");
        
        return `${day}/${month}/${year} ${hours}:${mins}:${secs}`;
    }

    // Build combined address string from address parts
    function buildCombinedAddress(addressObj) {
        const parts = [];
        if (addressObj.building_number) parts.push(addressObj.building_number);
        if (addressObj.building_name) parts.push(addressObj.building_name);
        if (addressObj.flat) parts.push("Flat " + addressObj.flat);
        if (addressObj.street) parts.push(addressObj.street);
        return parts.join(" ");
    }

    // Format previous addresses for display/export
    function formatPreviousAddresses(prev1, prev2) {
        const addrs = [];
        if (prev1) {
            const parts = [
                prev1.building_number,
                prev1.building_name,
                prev1.flat ? "Flat " + prev1.flat : "",
                prev1.street,
                prev1.post_town,
                prev1.post_code
            ].filter(Boolean);
            addrs.push(parts.join(", "));
        }
        if (prev2) {
            const parts = [
                prev2.building_number,
                prev2.building_name,
                prev2.flat ? "Flat " + prev2.flat : "",
                prev2.street,
                prev2.post_town,
                prev2.post_code
            ].filter(Boolean);
            addrs.push(parts.join(", "));
        }
        return addrs.join(" | ");
    }

    // ===== CSV Handling =====
    document.getElementById("csvFile").addEventListener("change", function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        document.getElementById("fileInfo").textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
        
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: function(results) {
                records = results.data.filter(r => r.first_name && r.last_name);
                log(`Loaded ${records.length} valid records from CSV`);
                renderPreview(records);
                document.getElementById("runBatchBtn").disabled = records.length === 0;
            },
            error: function(err) {
                log(`CSV parse error: ${err.message}`, "error");
            }
        });
    });

    function renderPreview(data) {
        const container = document.getElementById("previewContainer");
        if (!data.length) {
            container.textContent = "No valid records found.";
            return;
        }
        
        const cols = ["first_name", "last_name", "email", "mobile", "dob_day", "dob_month", "dob_year", "post_code"];
        let html = `<table id="previewTable"><thead><tr><th>#</th>`;
        cols.forEach(c => html += `<th>${c}</th>`);
        html += `</tr></thead><tbody>`;
        
        data.slice(0, 50).forEach((row, idx) => {
            html += `<tr><td>${idx + 1}</td>`;
            cols.forEach(c => html += `<td>${row[c] || ""}</td>`);
            html += `</tr>`;
        });
        
        html += `</tbody></table>`;
        if (data.length > 50) {
            html += `<p class="small">Showing first 50 of ${data.length} records.</p>`;
        }
        container.innerHTML = html;
    }

    // ===== Batch Processing =====
    async function runBatch() {
        if (isRunning) return;
        
        const baseUrl = document.getElementById("baseUrl").value.trim().replace(/\/$/, "");
        if (!baseUrl) {
            alert("Please enter the backend base URL");
            return;
        }
        
        const delayMs = parseInt(document.getElementById("delayMs").value) || 1500;
        const maxRecords = parseInt(document.getElementById("maxRecords").value) || 0;
        const limit = maxRecords > 0 ? Math.min(maxRecords, records.length) : records.length;
        
        isRunning = true;
        stopRequested = false;
        document.getElementById("runBatchBtn").disabled = true;
        document.getElementById("stopBtn").disabled = false;
        document.getElementById("exportBtn").disabled = true;
        
        // Clear previous export data
        exportData = [];
        
        clearLog();
        log(`Starting batch processing: ${limit} records`);
        log(`Base URL: ${baseUrl}`);
        log(`Delay: ${delayMs}ms between records`);
        log(`skipFLG: true (no FLG API calls)`);
        log("‚îÄ".repeat(50));
        
        const results = [];
        const campaign = `batch_import_${new Date().toISOString().split("T")[0]}`;
        const batchTimestamp = new Date().toISOString();
        
        for (let i = 0; i < limit; i++) {
            if (stopRequested) {
                log("Batch stopped by user", "warn");
                break;
            }
            
            const record = records[i];
            const idxLabel = i + 1;
            const dateOfBirth = formatDateYYYYMMDD(record);
            
            log(`[${idxLabel}/${limit}] Processing: ${record.first_name} ${record.last_name}`);
            
            // Validate required fields
            if (!record.first_name || !record.last_name || !dateOfBirth || !record.post_code) {
                log(`[${idxLabel}] ‚è≠Ô∏è Skipping - missing required fields`, "warn");
                results.push({
                    index: idxLabel,
                    first_name: record.first_name || "",
                    last_name: record.last_name || "",
                    status: "SKIPPED",
                    error: "Missing required fields"
                });
                continue;
            }
            
            try {
                // ===== Step 1: Call /query =====
                const queryPayload = {
                    firstName: (record.first_name || "").trim(),
                    lastName: (record.last_name || "").trim(),
                    middleName: (record.middle_name || "").trim(),
                    title: (record.title || "").trim(),
                    dateOfBirth: dateOfBirth,
                    flat: (record.flat || "").trim(),
                    building_name: (record.building_name || "").trim(),
                    building_number: (record.building_number || "").trim(),
                    street: (record.street || "").trim(),
                    district: (record.district || "").trim(),
                    county: (record.county || "").trim(),
                    post_town: (record.post_town || "").trim(),
                    post_code: (record.post_code || "").trim(),
                    previousAddress: buildPreviousAddress(record, "prev1"),
                    previousPreviousAddress: buildPreviousAddress(record, "prev2")
                };
                
                log(`[${idxLabel}] ‚Üí Calling /query...`);
                
                const queryResp = await fetch(`${baseUrl}/query`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(queryPayload)
                });
                
                if (!queryResp.ok) {
                    const errText = await queryResp.text();
                    throw new Error(`/query failed: ${queryResp.status} - ${errText}`);
                }
                
                // IMPORTANT: /query returns RAW Valifi response (not wrapped)
                const valifiResponse = await queryResp.json();
                const accounts = extractAccounts(valifiResponse);
                const pdfUrl = extractPdfUrl(valifiResponse);
                
                log(`[${idxLabel}] ‚Üê Found ${accounts.length} accounts, PDF: ${pdfUrl ? "Yes" : "No"}`);
                
                // ===== Step 2: Build summary for /upload_summary =====
                const mobile = (record.mobile || "").trim();
                const ukMobile = mobile.startsWith("44") ? "0" + mobile.substring(2) : mobile;
                const combinedAddress = buildCombinedAddress(queryPayload);
                const prevAddressesFormatted = formatPreviousAddresses(queryPayload.previousAddress, queryPayload.previousPreviousAddress);
                
                const summary = {
                    // Identity
                    firstName: queryPayload.firstName,
                    lastName: queryPayload.lastName,
                    middleName: queryPayload.middleName,
                    title: queryPayload.title,
                    dateOfBirth: dateOfBirth,
                    
                    // Contact
                    email: (record.email || "").trim(),
                    mobile: ukMobile,
                    phone1: ukMobile,
                    
                    // Address (multiple key formats for compatibility)
                    flat: queryPayload.flat,
                    building_name: queryPayload.building_name,
                    building_number: queryPayload.building_number,
                    street: queryPayload.street,
                    district: queryPayload.district,
                    county: queryPayload.county,
                    post_town: queryPayload.post_town,
                    towncity: queryPayload.post_town,
                    post_code: queryPayload.post_code,
                    postcode: queryPayload.post_code,
                    postCode: queryPayload.post_code,
                    
                    // Previous addresses
                    previousAddress: queryPayload.previousAddress,
                    previousPreviousAddress: queryPayload.previousPreviousAddress,
                    
                    // Valifi data - CRITICAL: Pass the entire response
                    valifiResponse: valifiResponse,
                    identityScore: 0,  // /query doesn't return this
                    identityVerified: true,  // Assume verified for batch
                    
                    // Lenders
                    accounts: accounts,
                    foundLenders: accounts,
                    additionalLenders: [],
                    
                    // Consents (standard batch defaults)
                    belmondChoiceConsent: true,
                    choiceReason: "Comprehensive",
                    otherReasonText: "",
                    existingRepresentationConsent: "No",
                    selectedProfessionalReps: [],
                    mammothPromotionsConsent: false,
                    motorFinanceConsent: true,
                    irresponsibleLendingConsent: true,
                    disengagementReason: "",
                    disengagementOtherText: "",
                    
                    // Signature & PDF
                    signatureBase64: "",
                    pdfUrl: pdfUrl,
                    
                    // Batch flags - CRITICAL
                    skipFLG: true,
                    skip_flg: true,
                    tlwSolicitorsSelected: false,
                    
                    // Tracking
                    campaign: campaign,
                    clientIp: "127.0.0.1",
                    session_id: `batch_${Date.now()}_${idxLabel}`,
                    source: "batch_import",
                    medium: "csv"
                };
                
                // ===== Step 3: Call /upload_summary =====
                log(`[${idxLabel}] ‚Üí Calling /upload_summary...`);
                
                const uploadResp = await fetch(`${baseUrl}/upload_summary`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(summary)
                });
                
                if (!uploadResp.ok) {
                    const errText = await uploadResp.text();
                    throw new Error(`/upload_summary failed: ${uploadResp.status} - ${errText}`);
                }
                
                const uploadResult = await uploadResp.json();
                const claimId = uploadResult.claim_id || "?";
                const leadIds = uploadResult.lead_ids || [];
                const valifiJsonReference = uploadResult.valifi_json_reference || "";
                
                // Parse valifi reference to extract S3 URL and CMC info
                let creditReportS3Url = "";
                let cmcSearchFound = "";
                try {
                    if (valifiJsonReference) {
                        const parsed = JSON.parse(valifiJsonReference);
                        creditReportS3Url = parsed.s3_url || "";
                        cmcSearchFound = parsed.cmc_search_found || false;
                    }
                } catch (e) {
                    // If not valid JSON, leave empty
                }
                
                log(`[${idxLabel}] ‚úì Success! Claim ID: ${claimId}, Leads: ${leadIds.length}`, "success");
                
                // ===== Step 4: Build export data - ONE ROW PER LEAD ID =====
                for (const lead of leadIds) {
                    const isDCA = lead.lead_type === "DCA";
                    
                    const exportRow = {
                        // ========== CLAIMANT LEVEL (claims_tracking) ==========
                        claim_id: claimId,
                        
                        // Personal Information
                        first_name: summary.firstName,
                        last_name: summary.lastName,
                        middle_name: summary.middleName,
                        title: summary.title,
                        email: summary.email,
                        mobile: summary.mobile,
                        date_of_birth: formatDateDDMMYYYY(dateOfBirth),
                        
                        // Current Address
                        flat: summary.flat,
                        building_number: summary.building_number,
                        building_name: summary.building_name,
                        street: summary.street,
                        district: summary.district,
                        post_town: summary.post_town,
                        county: summary.county,
                        post_code: summary.post_code,
                        current_address_combined: combinedAddress,
                        previous_addresses: prevAddressesFormatted,
                        
                        // Identity Verification
                        identity_score: summary.identityScore,
                        identity_verified: summary.identityVerified,
                        valifi_response_stored: true,
                        
                        // Lenders Summary
                        lenders_found_count: accounts.length,
                        lenders_found_list: accounts.map(a => a.displayName || a.lenderName || "Unknown").join(", "),
                        lenders_manual_count: 0,
                        lenders_eligible: leadIds.filter(l => l.reference === "FA Eligible").length,
                        lenders_ineligible: leadIds.filter(l => l.reference !== "FA Eligible").length,
                        
                        // Consents
                        motor_finance_consent: summary.motorFinanceConsent,
                        irresponsible_lending_consent: summary.irresponsibleLendingConsent,
                        belmond_choice_consent: summary.belmondChoiceConsent,
                        choice_reason: summary.choiceReason,
                        other_reason_text: summary.otherReasonText,
                        existing_representation_consent: summary.existingRepresentationConsent,
                        mammoth_promotions_consent: summary.mammothPromotionsConsent,
                        disengagement_reason: summary.disengagementReason,
                        disengagement_other_text: summary.disengagementOtherText,
                        
                        // Campaign/Source
                        campaign: campaign,
                        client_ip: summary.clientIp,
                        
                        // Status
                        claim_submitted: true,
                        submission_datetime: formatDateTimeDDMMYYYY(batchTimestamp),
                        leads_created_count: leadIds.length,
                        pdf_url: pdfUrl,
                        credit_report_s3_url: creditReportS3Url,
                        cmc_in_credit_report: cmcSearchFound ? "Yes" : "No",
                        signature_provided: false,
                        created_at: formatDateTimeDDMMYYYY(batchTimestamp),
                        claim_status: "pending",
                        lead_source: "batch_import",
                        
                        // ========== LEAD ID LEVEL (lead_ids_tracking) ==========
                        lead_id: lead.lead_id,
                        lead_group: lead.lead_group,
                        lead_type: lead.lead_type,
                        lender_name: lead.lender_name,
                        reference: lead.reference,
                        cost: lead.cost,
                        
                        // Lender Details
                        account_number: lead.account_number,
                        start_date: formatDateDDMMYYYY(lead.start_date),
                        outstanding_balance: lead.outstanding_balance,
                        monthly_payment: lead.monthly_payment,
                        lender_data_json: lead.lender_data_json || "",
                        
                        // Eligibility
                        is_eligible: lead.is_eligible,
                        ineligible_reason: lead.ineligible_reason || "",
                        is_manual: lead.is_manual,
                        within_date_range: lead.within_date_range,
                        
                        // Match Info
                        valifi_original_name: lead.valifi_original_name || "",
                        matched_lender_id: lead.match_info?.lender_id || "",
                        matched_lender_name: lead.match_info?.lender_name || "",
                        fortress_name: lead.match_info?.fortress_name || "",
                        flg_lender_name_matched: lead.match_info?.flg_lender_name || "",
                        fuzzy_score: lead.match_info?.fuzzy_score || "",
                        match_type: lead.match_info?.match_type || "",
                        matched_via: lead.match_info?.matched_via || "",
                        
                        // ========== FLG FIELDS - BASE (all leads) ==========
                        flg_medium: campaign,
                        flg_title: summary.title,
                        flg_firstname: summary.firstName,
                        flg_lastname: summary.lastName,
                        flg_dateOfBirth: formatDateDDMMYYYY(dateOfBirth),
                        flg_phone1: summary.mobile,
                        flg_email: summary.email,
                        flg_address: combinedAddress,
                        flg_towncity: summary.post_town,
                        flg_postcode: summary.post_code,
                        flg_introducer: "61445",
                        flg_applicant_id: claimId,
                        flg_data25_signature: "[base64 signature]",
                        flg_data28_datetime: formatDateTimeDDMMYYYY(new Date()),
                        flg_data29_client_ip: summary.clientIp,
                        flg_data31_pdf_url: isDCA ? pdfUrl : "",
                        
                        // Lead type specific
                        flg_leadgroup: lead.lead_group,
                        flg_source: isDCA ? "Belmondclaims.com" : "",
                        flg_reference: lead.reference,
                        flg_cost: lead.cost,
                        
                        // ========== FLG FIELDS - DCA SPECIFIC ==========
                        flg_data2_lender_name: isDCA ? lead.lender_name : "",
                        flg_data5_outstanding_balance: isDCA ? lead.outstanding_balance : "",
                        flg_data9_account_number: isDCA ? lead.account_number : "",
                        flg_data12_start_date: isDCA ? formatDateDDMMYYYY(lead.start_date) : "",
                        flg_data14_prev_addresses: isDCA ? prevAddressesFormatted : "",
                        flg_data32_valifi_json_url: isDCA ? valifiJsonReference : "",
                        flg_data34_account_json: isDCA ? (lead.lender_data_json || "") : "",
                        flg_data47_cmc_info: "",
                        
                        // ========== FLG FIELDS - IRL SPECIFIC ==========
                        flg_data1_lender_name: !isDCA ? lead.lender_name : "",
                        flg_data5_account_number_irl: !isDCA ? lead.account_number : "",
                        flg_data33_monthly_payment: !isDCA ? lead.monthly_payment : "",
                        flg_data36_valifi_json_url: !isDCA ? valifiJsonReference : "",
                        flg_data37_start_date: !isDCA ? formatDateDDMMYYYY(lead.start_date) : "",
                        flg_data38_address2: !isDCA ? "[address 2]" : "",
                        flg_data39_address3_onwards: !isDCA ? "[address 3+]" : "",
                        flg_data48_account_json_or_pdf: !isDCA ? (lead.lender_data_json || pdfUrl) : ""
                    };
                    
                    exportData.push(exportRow);
                }
                
                results.push({
                    index: idxLabel,
                    first_name: record.first_name,
                    last_name: record.last_name,
                    status: "OK",
                    claim_id: claimId,
                    lenders: accounts.length,
                    leads: leadIds.length
                });
                
            } catch (err) {
                log(`[${idxLabel}] Error: ${err.message}`, "error");
                results.push({
                    index: idxLabel,
                    first_name: record.first_name || "",
                    last_name: record.last_name || "",
                    status: "ERROR",
                    error: err.message
                });
            }
            
            // Delay between records
            if (i < limit - 1 && !stopRequested) {
                await new Promise(res => setTimeout(res, delayMs));
            }
        }
        
        // Complete
        log("‚îÄ".repeat(50));
        const okCount = results.filter(r => r.status === "OK").length;
        const errCount = results.filter(r => r.status === "ERROR").length;
        const skipCount = results.filter(r => r.status === "SKIPPED").length;
        log(`Batch complete: ${okCount} OK, ${errCount} errors, ${skipCount} skipped`);
        log(`Total Lead ID rows for export: ${exportData.length}`);
        
        renderResults(results);
        
        isRunning = false;
        document.getElementById("runBatchBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;
        document.getElementById("exportBtn").disabled = exportData.length === 0;
    }

    function renderResults(results) {
        const container = document.getElementById("resultsContainer");
        if (!results.length) {
            container.textContent = "No results yet.";
            return;
        }
        
        const okCount = results.filter(r => r.status === "OK").length;
        const errCount = results.filter(r => r.status === "ERROR").length;
        const skipCount = results.filter(r => r.status === "SKIPPED").length;
        
        let html = `<div style="margin-bottom: 10px;">
            <span class="badge badge-ok">${okCount} OK</span>
            <span class="badge badge-error">${errCount} Errors</span>
            <span class="badge badge-skip">${skipCount} Skipped</span>
        </div>`;
        
        html += `<div style="max-height: 300px; overflow: auto;">`;
        html += `<table id="resultsTable"><thead><tr>
            <th>#</th><th>First</th><th>Last</th><th>Status</th><th>Claim ID</th><th>Lenders</th><th>Leads</th><th>Error</th>
        </tr></thead><tbody>`;
        
        results.forEach(r => {
            const statusClass = r.status === "OK" ? "badge-ok" : r.status === "SKIPPED" ? "badge-skip" : "badge-error";
            html += `<tr>
                <td>${r.index}</td>
                <td>${r.first_name}</td>
                <td>${r.last_name}</td>
                <td><span class="badge ${statusClass}">${r.status}</span></td>
                <td>${r.claim_id || ""}</td>
                <td>${r.lenders || ""}</td>
                <td>${r.leads || ""}</td>
                <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${r.error || ""}</td>
            </tr>`;
        });
        
        html += `</tbody></table></div>`;
        container.innerHTML = html;
    }

    // ===== Excel Export =====
    function exportToExcel() {
        if (exportData.length === 0) {
            alert("No data to export. Run a batch first.");
            return;
        }
        
        log("Generating Excel file...");
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        
        // Create worksheet from export data
        const ws = XLSX.utils.json_to_sheet(exportData);
        
        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, "Batch Results");
        
        // Generate filename with timestamp
        const timestamp = new Date().toISOString().split("T")[0];
        const filename = `batch_export_${timestamp}.xlsx`;
        
        // Download the file
        XLSX.writeFile(wb, filename);
        
        log(`Excel file downloaded: ${filename}`, "success");
        log(`  - Total rows: ${exportData.length}`);
    }

    // ===== Event Listeners =====
    document.getElementById("runBatchBtn").addEventListener("click", runBatch);
    
    document.getElementById("stopBtn").addEventListener("click", function() {
        stopRequested = true;
        log("Stop requested - will halt after current record...", "warn");
    });
    
    document.getElementById("exportBtn").addEventListener("click", exportToExcel);
    
    // ===== Tab Navigation =====
    document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.addEventListener("click", function() {
            // Remove active from all tabs and content
            document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
            document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
            
            // Add active to clicked tab
            this.classList.add("active");
            
            // Show corresponding content
            const tabId = this.getAttribute("data-tab");
            document.getElementById("tab-" + tabId).classList.add("active");
        });
    });
    
    // ===== Webhook Functionality =====
    let parsedLeadIds = [];
    
    function webhookLog(msg, level = "info") {
        const el = document.getElementById("webhookLogContent");
        const container = document.getElementById("webhookLog");
        container.style.display = "block";
        
        const ts = new Date().toISOString().split("T")[1].slice(0, 8);
        const prefix = level === "error" ? "‚ùå" : level === "warn" ? "‚ö†Ô∏è" : level === "success" ? "‚úÖ" : "‚ÑπÔ∏è";
        el.textContent += `[${ts}] ${prefix} ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }
    
    function clearWebhookLog() {
        document.getElementById("webhookLogContent").textContent = "";
        document.getElementById("webhookLog").style.display = "none";
    }
    
    function parseLeadIds() {
        const input = document.getElementById("leadIdsInput").value;
        
        // Split by newlines, tabs, commas, spaces
        const rawIds = input.split(/[\n\t,\s]+/).map(s => s.trim()).filter(s => s.length > 0);
        
        // Filter to only valid-looking lead IDs (numbers, or alphanumeric with underscores for fake IDs)
        parsedLeadIds = rawIds.filter(id => /^[\w\d_-]+$/.test(id));
        
        // Update count display
        document.getElementById("leadCountDisplay").innerHTML = 
            `Lead IDs detected: <strong>${parsedLeadIds.length}</strong>`;
        
        // Update preview
        const previewContainer = document.getElementById("parsedLeadsPreview");
        const previewList = document.getElementById("parsedLeadsList");
        
        if (parsedLeadIds.length > 0) {
            previewContainer.style.display = "block";
            previewList.innerHTML = parsedLeadIds.map((id, idx) => 
                `<span style="display: inline-block; background: #e0e7ff; padding: 2px 8px; margin: 2px; border-radius: 4px;">${idx + 1}. ${id}</span>`
            ).join("");
            
            document.getElementById("sendWebhookBtn").disabled = false;
        } else {
            previewContainer.style.display = "none";
            document.getElementById("sendWebhookBtn").disabled = true;
        }
        
        return parsedLeadIds;
    }
    
    // Auto-parse on input change
    document.getElementById("leadIdsInput").addEventListener("input", function() {
        const input = this.value;
        const rawIds = input.split(/[\n\t,\s]+/).map(s => s.trim()).filter(s => s.length > 0);
        const count = rawIds.filter(id => /^[\w\d_-]+$/.test(id)).length;
        document.getElementById("leadCountDisplay").innerHTML = 
            `Lead IDs detected: <strong>${count}</strong>`;
    });
    
    document.getElementById("parseLeadsBtn").addEventListener("click", function() {
        clearWebhookLog();
        const ids = parseLeadIds();
        if (ids.length > 0) {
            webhookLog(`Parsed ${ids.length} lead IDs`);
        } else {
            webhookLog("No valid lead IDs found in input", "warn");
        }
    });
    
    document.getElementById("clearLeadsBtn").addEventListener("click", function() {
        document.getElementById("leadIdsInput").value = "";
        parsedLeadIds = [];
        document.getElementById("leadCountDisplay").innerHTML = `Lead IDs detected: <strong>0</strong>`;
        document.getElementById("parsedLeadsPreview").style.display = "none";
        document.getElementById("sendWebhookBtn").disabled = true;
        clearWebhookLog();
    });
    
    document.getElementById("sendWebhookBtn").addEventListener("click", async function() {
        if (parsedLeadIds.length === 0) {
            parseLeadIds();
        }
        
        if (parsedLeadIds.length === 0) {
            alert("No lead IDs to send. Please paste some lead IDs first.");
            return;
        }
        
        const webhookUrl = document.getElementById("webhookUrl").value.trim();
        if (!webhookUrl) {
            alert("Please enter a webhook URL");
            return;
        }
        
        clearWebhookLog();
        webhookLog(`Sending ${parsedLeadIds.length} lead IDs to webhook...`);
        webhookLog(`URL: ${webhookUrl}`);
        
        const payload = {
            leads: parsedLeadIds
        };
        
        webhookLog(`Payload: ${JSON.stringify(payload)}`);
        
        try {
            this.disabled = true;
            this.textContent = "‚è≥ Sending...";
            
            const response = await fetch(webhookUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
            });
            
            const responseText = await response.text();
            
            if (response.ok) {
                webhookLog(`‚úì Webhook responded with status ${response.status}`, "success");
                webhookLog(`Response: ${responseText}`, "success");
            } else {
                webhookLog(`‚úó Webhook failed with status ${response.status}`, "error");
                webhookLog(`Response: ${responseText}`, "error");
            }
        } catch (err) {
            webhookLog(`‚úó Failed to send webhook: ${err.message}`, "error");
        } finally {
            this.disabled = false;
            this.textContent = "üì§ Send to Webhook";
        }
    });
    </script>
</body>
</html>